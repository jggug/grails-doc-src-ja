{hidden}
h4. The Basics
{hidden}

h4. 基本

{hidden}
You use the @grails.test.mixin.TestFor@ annotation to unit test controllers. Using @TestFor@ in this manner activates the @grails.test.mixin.web.ControllerUnitTestMixin@ and its associated API. For example:
{hidden}

コントローラUnitテストには、@grails.test.mixin.TestFor@アノテーションを使用します。@TestFor@の作法として、@grails.test.mixin.web.ControllerUnitTestMixin@とそれに関係するAPIを使用します。

{code:java}
import grails.test.mixin.TestFor

@TestFor(SimpleController)
class SimpleControllerTests {
    void testSomething() {

    }
}
{code}

{hidden}
Adding the @TestFor@ annotation to a controller causes a new @controller@ field to be automatically created for the controller under test.
{hidden}

@TestFor@アノテーションにコントローラを追加することにより、@controller@フィールドにテスト対象のコントローラが自動的に生成されます。

{hidden}
{note}
The @TestFor@ annotation will also automatically annotate any public methods starting with "test" with JUnit 4's @Test annotation. If any of your test method don't start with "test" just add this manually
{note}
{hidden}

{note}
@TestFor@アノテーションは、JUnit 4 の @Testアノテーションの "test" 文字列から始まるパブリックメソッドに自動的にアノテーションをつけます。もし、テストするメソッドが "test" 文字列から始まっていないならば、"test" 文字列を手動で付け足してください。
{note}

{hidden}
To test the simplest "Hello World"-style example you can do the following:
{hidden}

最もシンプルな Hello World 形式のテストは次の通りです。

{code:java}
// Test class
class SimpleController {
    def hello() {
        render "hello"
    }
}
{code}

{code:java}
void testHello() {
    controller.hello()

    assert response.text == 'hello'
}
{code}

{hidden}
The @response@ object is an instance of @GrailsMockHttpServletResponse@ (from the package @org.codehaus.groovy.grails.plugins.testing@) which extends Spring's @MockHttpServletResponse@ class and has a number of useful methods for inspecting the state of the response.
{hidden}

@response@オブジェクト（@org.codehaus.groovy.grails.plugins.testing@パッケージに含まれている）は、@GrailsMockHttpServletResponse@のインスタンスです。Spring の @MockHttpServletResponse@ クラスを継承しており、レスポンスの状態を調べる便利なメソッドが存在します。

{hidden}
For example to test a redirect you can use the @redirectedUrl@ property:
{hidden}

例えば、リダイレクトをテストするために@redirectedUrl@プロパティを使用します。

{code:java}
// Test class
class SimpleController {
    def index() {
        redirect action: 'hello'
    }
    ...
}
{code}

{code:java}
void testIndex() {
    controller.index()

    assert response.redirectedUrl == '/simple/hello'
}
{code}

{hidden}
Many actions make use of the parameter data associated with the request. For example, the 'sort', 'max', and 'offset' parameters are quite common. Providing these in the test is as simple as adding appropriate values to a special @params@ variable:
{hidden}

ほとんどのアクションはリクエストに関係するパラメータを使用します。例えば、'sort'、'max'、'offset'パラメータが一般的です。これらのパラメータをテストで利用することは簡単であり、@params@変数に値を代入します。

{code:java}
void testList() {
    params.sort = "name"
    params.max = 20
    params.offset = 0

    controller.list()
    ...
}
{code}

{hidden}
You can even control what type of request the controller action sees by setting the @method@ property of the mock request:
{hidden}

リクエストモックの@method@プロパティにリクエストタイプを設定することにより、リクエストタイプ毎のコントローラのアクションを確認できます。

{code:java}
void testSave() {
    request.method = "POST"
    controller.save()
    ...
}
{code}

{hidden}
This is particularly important if your actions do different things depending on the type of the request. Finally, you can mark a request as AJAX like so:
{hidden}

リクエストタイプに応じてアクションが違った挙動をする場合、これは非常に重要です。さらに、次のようにAjaxとしてリクエストを作ることもできます。

{code:java}
void testGetPage() {
    request.method = "POST"
    request.makeAjaxRequest()
    controller.getPage()
    ...
}
{code}

{hidden}
You only need to do this though if the code under test uses the @xhr@ property on the request.
{hidden}

テスト対象コードのリクエストで@xhr@プロパティを使用してたとしても、これを実行するだけです。

{hidden}
h4. Testing View Rendering
{hidden}

h4. 画面レンダリングテスト

{hidden}
To test view rendering you can inspect the state of the controller's @modelAndView@ property (an instance of @org.springframework.web.servlet.ModelAndView@) or you can use the @view@ and @model@ properties provided by the mixin:
{hidden}

コントローラの@modelAndView@プロパティ（@org.springframework.web.servlet.ModelAndView@のインスタンス）、または、Mixinで提供されている@view@と@model@プロパティを使用することにより、画面レンダリングをテストすることができます。

{code:java}
// Test class
class SimpleController {
    def home() {
        render view: "homePage", model: [title: "Hello World"]
    }
    ...
}
{code}

{code:java}
void testIndex() {
    controller.home()

    assert view == "/simple/homePage"
    assert model.title == "Hello World"
}
{code}

{hidden}
Note that the view string is the absolute view path, so it starts with a '/' and will include path elements, such as the directory named after the action's controller.
{hidden}

画面の文字列は絶対パスであるので、'/'で始まり、アクションコントローラの後にあるディレクトリ名などのパスを含むことに注意してください。

{hidden}
h4. Testing Template Rendering
{hidden}

h4. テンプレートレンダリングテスト

{hidden}
Unlike view rendering, template rendering will actually attempt to write the template directly to the response rather than returning a @ModelAndView@ hence it requires a different approach to testing.
{hidden}

画面レンダリングと異なり、テンプレートレンダリングは @ModelAndView@ を返すのではなく、テンプレートをレスポンスに代入します。そのため、使い方が異なります。

{hidden}
Consider the following controller action:
{hidden}

次のコントローラアクションを見てください。

{code:java}
class SimpleController {
    def display() {
        render template:"snippet"
    }
}
{code}

{hidden}
In this example the controller will look for a template in @grails-app/views/simple/_snippet.gsp@. You can test this as follows:
{hidden}

この例では、コントローラは @grails-app/views/simple/_snippet.gsp@. 内でテンプレートを探します。そして、次のようにテストをします。

{code:java}
void testDisplay() {
    controller.display()
    assert response.text == 'contents of template'
}
{code}

{hidden}
However, you may not want to render the real template, but just test that is was rendered. In this case you can provide mock Groovy Pages:
{hidden}

実際のテンプレートを表示したくないとしても、存在するテストが表示されます。次の場合、GroovyPageをモック化しています。

{code:java}
void testDisplay() {
    views['/simple/_snippet.gsp'] = 'mock contents'
    controller.display()
    assert response.text == 'mock contents'
}
{code}

{hidden}
h4. Testing Actions Which Return A Map
{hidden}

h4. マップを返すアクションをテスト

{hidden}
When a controller action returns a @java.util.Map@ that @Map@ may be inspected directly to assert that it contains the expected data:
{hidden}

コントローラアクションが @java.util.Map@ を返すとき、@Map@ は期待された値が含まれているか検証するため直接検査されるかもされない。

{code:java}
class SimpleController {
    def showBookDetails() {
        [title: 'The Nature Of Necessity', author: 'Alvin Plantinga']
    }
}
{code}

{code:java}
import grails.test.mixin.*

@TestFor(SimpleController)
class SimpleControllerTests {

    void testShowBookDetails() {
        def model = controller.showBookDetails()

        assert model.author == 'Alvin Plantinga'
    }
}
{code}

{hidden}
h4. Testing XML and JSON Responses
{hidden}

h4. XMLとJSONレスポンスのテスト

{hidden}
XML and JSON response are also written directly to the response. Grails' mocking capabilities provide some conveniences for testing XML and JSON response. For example consider the following action:
{hidden}

XMLとJSONレスポンスもまた、レスポンスに直接代入されます。Grailsのモックは、XMLとJSONレスポンスをテストするための便利なものを提供しています。

{code:java}
def renderXml() {
    render(contentType:"text/xml") {
        book(title:"Great")
    }
}
{code}

{hidden}
This can be tested using the @xml@ property of the response:
{hidden}

次の例は、レスポンスの@xml@プロパティを使ってテストしています。

{code:java}
void testRenderXml() {
    controller.renderXml()
    assert "<book title='Great'/>" == response.text
    assert "Great" == response.xml.@title.text()
}
{code}

{hidden}
The @xml@ property is a parsed result from Groovy's "XmlSlurper":http://groovy.codehaus.org/Reading+XML+using+Groovy's+XmlSlurper class which is very convenient for parsing XML.
{hidden}

@xml@プロパティは、XMLをパースするためにとても便利なGroovyの"XmlSlurper":http://groovy.codehaus.org/Reading+XML+using+Groovys+XmlSlurper でパースされた結果です。

{hidden}
Testing JSON responses is pretty similar, instead you use the @json@ property:
{hidden}

@json@プロパティを使うだけで、JSONレスポンスのテストもかなり似ています。

{code:java}
// controller action
def renderJson() {
    render(contentType:"text/json") {
        book = "Great"
    }
}
{code}

{code:java}
// test
void testRenderJson() {

    controller.renderJson()

    assert '{"book":"Great"}' == response.text
    assert "Great" == response.json.book
}

{code}

{hidden}
The @json@ property is an instance of @org.codehaus.groovy.grails.web.json.JSONElement@ which is a map-like structure that is useful for parsing JSON responses.
{hidden}

@json@プロパティは、JSONレスポンスをパースするために便利なマップライクな仕組みがある @org.codehaus.groovy.grails.web.json.JSONElement@ のインスタンスです。

{hidden}
h4. Testing XML and JSON Requests
{hidden}

h4. XMLとJSONリクエストのテスト

{hidden}
Grails provides various convenient ways to automatically parse incoming XML and JSON packets. For example you can bind incoming JSON or XML requests using Grails' data binding:
{hidden}

Grailsは、入力されるXMLとJSONパケットを自動的にパースするためのいろいろな便利な方法を提供しています。例えば、入力されるJSONかXMLリクエストをGrailsのデータバインディングを使ってバインドできます。

{code}
def consumeBook() {
    def b = new Book(params['book'])

    render b.title
}
{code}

{hidden}
To test this Grails provides an easy way to specify an XML or JSON packet via the @xml@ or @json@ properties. For example the above action can be tested by specifying a String containing the XML:
{hidden}

次のテストでは、 @xml@ や @json@ プロパティを用いてXMLやJSONリクエストを定義しています。例えば、上記のアクションはXMLの文字列を定義することによってテストができます。

{code}
void testConsumeBookXml() {
    request.xml = '<book><title>The Shining</title></book>'
    controller.consumeBook()

    assert response.text == 'The Shining'
}
{code}

{hidden}
Or alternatively a domain instance can be specified and it will be auto-converted into the appropriate XML request:
{hidden}

もしくは、ドメインインスタンスを定義し、適切なXMLリクエストに自動変換してテストをします。

{code}
void testConsumeBookXml() {
    request.xml = new Book(title:"The Shining")
    controller.consumeBook()

    assert response.text == 'The Shining'
}
{code}

{hidden}
The same can be done for JSON requests:
{hidden}

同じことはJSONリクエストでもできます。

{code}
void testConsumeBookJson() {
    request.json = new Book(title:"The Shining")
    controller.consumeBook()

    assert response.text == 'The Shining'
}
{code}

{hidden}
If you prefer not to use Grails' data binding but instead manually parse the incoming XML or JSON that can be tested too. For example consider the controller action below:
{hidden}

もし、Grailsのデータバインディングを使いたくないならば、入力するXMLかJSONを手動パースしてください。次のコントローラアクションを見てください。

{code}
def consume() {
    request.withFormat {
        xml {
            render request.XML.@title
        }
        json {
            render request.JSON.title
        }
    }
}
{code}

{hidden}
To test the XML request you can specify the XML as a string:
{hidden}

XMLリクエストをテストするためには、XMLの文字列を定義します。

{code}
void testConsumeXml() {
    request.xml = '<book title="The Stand" />'

    controller.consume()

    assert response.text == 'The Stand'
}
{code}

{hidden}
And, of course, the same can be done for JSON:
{hidden}

もちろん、同じことはJSONでもできます。

{code}
void testConsumeJson() {
    request.json = '{title:"The Stand"}'
    controller.consume()

    assert response.text == 'The Stand'
}
{code}

{hidden}
h4. Testing Spring Beans
{hidden}

h4. Spring Beanのテスト

{hidden}
When using @TestFor@ only a subset of the Spring beans available to a running Grails application are available. If you wish to make additional beans available you can do so with the @defineBeans@ method of @GrailsUnitTestMixin@:
{hidden}

@TestFor@を使うとき、Grailsアプリケーションを実行させるために利用できるSpring Beanのサブセットだけが利用できます。もし、利用できるBeanを追加したいならば、@GrailsUnitTestMixin@の@defineBeans@メソッドを使うことにより、Beanを追加できます。

{code:java}
class SimpleController {
    SimpleService simpleService
    def hello() {
        render simpleService.sayHello()
    }
}
{code}

{code:java}
void testBeanWiring() {
    defineBeans {
        simpleService(SimpleService)
    }

    controller.hello()

    assert response.text == "Hello World"
}
{code}

{hidden}
The controller is auto-wired by Spring just like in a running Grails application. Autowiring even occurs if you instantiate subsequent instances of the controller:
{hidden}

実行中のGrailsアプリケーション上で、Springはコントローラを自動割り当てします。もし、次の順番でコントローラをインスタンス化させた場合、自動割り当てが発生します。

{code:java}
void testAutowiringViaNew() {
    defineBeans {
        simpleService(SimpleService)
    }

    def controller1 = new SimpleController()
    def controller2 = new SimpleController()

    assert controller1.simpleService != null
    assert controller2.simpleService != null
}
{code}

{hidden}
h4. Testing Mime Type Handling
{hidden}

h4. MIME Type処理のテスト

{hidden}
You can test mime type handling and the @withFormat@ method quite simply by setting the response's @format@ attribute:
{hidden}

MIME Type処理と@withFormat@メソッドは、レスポンスの@format@属性を設定することにより簡単にテストができます。

{code:java}
// controller action
def sayHello() {
    def data = [Hello:"World"]
    withFormat {
        xml { render data as XML }
        html data
    }
}
{code}

{code:java}
// test
void testSayHello() {
    response.format = 'xml'
    controller.sayHello()

    String expected = '<?xml version="1.0" encoding="UTF-8"?>' +
                      '<map><entry key="Hello">World</entry></map>'

    assert expected == response.text
}
{code}

{hidden}
h4. Testing Duplicate Form Submissions
{hidden}

h4. フォームの２重送信テスト

{hidden}
Testing duplicate form submissions is a little bit more involved. For example if you have an action that handles a form such as:
{hidden}

例えば、次のようなフォームを処理するアクションが存在する場合、フォームの２重送信をテストすることは少し複雑です。

{code:java}
def handleForm() {
    withForm {
        render "Good"
    }.invalidToken {
        render "Bad"
    }
}
{code}

{hidden}
you want to verify the logic that is executed on a good form submission and the logic that is executed on a duplicate submission. Testing the bad submission is simple. Just invoke the controller:
{hidden}

良いフォーム送信で実行されるロジックと２重送信で実行されるロジックを検証したい場合、コントローラのメソッドを呼び出すだけで悪い送信は簡単にテストができます。

{code:java}
void testDuplicateFormSubmission() {
    controller.handleForm()
    assert "Bad" == response.text
}
{code}

{hidden}
Testing the successful submission requires providing an appropriate @SynchronizerToken@:
{hidden}

成功する送信をテストするためには、適切な @SynchronizerToken@ が必要です。

{code:java}
import org.codehaus.groovy.grails.web.servlet.mvc.SynchronizerToken
...

void testValidFormSubmission() {
    def token = SynchronizerToken.store(session)
    params[SynchronizerToken.KEY] = token.currentToken.toString()

    controller.handleForm()
    assert "Good" == response.text
}
{code}

{hidden}
If you test both the valid and the invalid request in the same test be sure to reset the response between executions of the controller:
{hidden}

もし、有効/無効のリクエストを両方ともテストしたい場合、コントローラのメソッド実行の間で、レスポンスをリセットしてください。

{code:java}
controller.handleForm() // first execution
...
response.reset()
...
controller.handleForm() // second execution
{code}

{hidden}
h4. Testing File Upload
{hidden}

h4. ファイルアップロードのテスト

{hidden}
You use the @GrailsMockMultipartFile@ class to test file uploads. For example consider the following controller action:
{hidden}

ファイルアップロードをテストするためには、@GrailsMockMultipartFile@クラスを使います。例えば、次のコントローラアクションを見てください。

{code:java}
def uploadFile() {
    MultipartFile file = request.getFile("myFile")
    file.transferTo(new File("/local/disk/myFile"))
}
{code}

{hidden}
To test this action you can register a @GrailsMockMultipartFile@ with the request:
{hidden}

このアクションをテストするためには、リクエストに @GrailsMockMultipartFile@ を代入してください。

{code:java}
void testFileUpload() {
    final file = new GrailsMockMultipartFile("myFile", "foo".bytes)
    request.addFile(file)
    controller.uploadFile()

    assert file.targetFileLocation.path == "/local/disk/myFile"
}
{code}

{hidden}
The @GrailsMockMultipartFile@ constructor arguments are the name and contents of the file. It has a mock implementation of the @transferTo@ method that simply records the @targetFileLocation@ and doesn't write to disk.
{hidden}

@GrailsMockMultipartFile@ のコンストラクタの引数はファイル名とファイルの内容です。簡単に @targetFileLocation@ を再コード化し、ディスクに書き込まない@transferTo@メソッドのモック実装を持っています。

{hidden}
h4. Testing Command Objects
{hidden}

h4. Commnadオブジェクトのテスト

{hidden}
Special support exists for testing command object handling with the @mockCommandObject@ method. For example consider the following action:
{hidden}

@mockCommandObject@メソッドにはCommandオブジェクトの処理をテストするための特別な機能があります。例えば、次のアクションを見てください。

{code:java}
def handleCommand(SimpleCommand simple) {
    if (simple.hasErrors()) {
        render "Bad"
    }
    else {
        render "Good"
    }
}
{code}

{hidden}
To test this you mock the command object, populate it and then validate it as follows:
{hidden}

これをテストするために、次のようにCommandオブジェクトをモック化し、データを投入し、検証してください。

{code:java}
void testInvalidCommand() {
    def cmd = mockCommandObject(SimpleCommand)
    cmd.name = '' // doesn't allow blank names

    cmd.validate()
    controller.handleCommand(cmd)

    assert response.text == 'Bad'
}
{code}

{hidden}
h4. Testing Calling Tag Libraries
{hidden}

h4. タグライブラリの呼び出しテスト

{hidden}
You can test calling tag libraries using @ControllerUnitTestMixin@, although the mechanism for testing the tag called varies from tag to tag. For example to test a call to the @message@ tag, add a message to the @messageSource@. Consider the following action:
{hidden}

@ControllerUnitTestMixin@ を使ってタグライブラリの呼び出しをテストできます。タグが呼ばれるテストの仕組みはタグからタグへと変化します。例えば、@message@タグを呼び出すテストでは、@messageSource@.にメッセージを加えます。次のアクションを見てください。

{code:java}
def showMessage() {
    render g.message(code: "foo.bar")
}
{code}

{hidden}
This can be tested as follows:
{hidden}

これは次のようにテストをします。

{code:java}
void testRenderBasicTemplateWithTags() {
    messageSource.addMessage("foo.bar", request.locale, "Hello World")

    controller.showMessage()

    assert response.text == "Hello World"
}
{code}
